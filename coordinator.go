package commit

import (
	"cs351/labrpc"
	"log"
	"sync"
	"sync/atomic"
)

// Responses to the client

type ResponseMsg struct {
	tid        int
	committed  bool
	readValues map[string]interface{}
}

type Coordinator struct {
	servers  []*labrpc.ClientEnd
	respChan chan ResponseMsg
	dead     int32

	tran     map[int]*Transaction // transaction ID : transaction
	serversN int                  // number of servers
	mu       sync.Mutex
}

type Transaction struct {
	Phase      string                 // Current phase: Prepare, PreCommit, Committed, Aborted
	Relevant   map[int]bool           // Servers with operations for this transaction
	ReadValues map[string]interface{} // Values from Get operations
}

// Start the 3PC protocol for a particular transaction
// TID is a unique transaction ID generated by the client
// This may be called concurrently

func (co *Coordinator) FinishTransaction(tid int) {
	co.mu.Lock()
	// Check if the transaction is already in progress

	if _, exists := co.tran[tid]; !exists {
		// Create a new transaction and add it to the map
		co.tran[tid] = &Transaction{
			Phase:      PhasePrepare,
			Relevant:   make(map[int]bool),
			ReadValues: make(map[string]interface{}),
		}
	}

	tran := co.tran[tid]
	co.mu.Unlock()

	go func() {

		// ======================
		// PHASE 1: PREPARE
		// ======================

		relevant := make(map[int]bool)
		votes := make(map[int]bool)
		allVotedYes := true

		// Send Prepare RPC to all servers

		log.Printf("Coordinator: Sending Prepare RPC to all servers for transaction %d\n", tid)

		for i := 0; i < co.serversN; i++ {
			log.Printf("Coordinator: Sending Prepare RPC to server %d for transaction %d\n", i, tid)
			if co.killed() {
				return
			}

			args := &RPCArgs{Tid: tid}
			reply := &PrepareReply{}

			for !co.sendPrepare(i, args, reply) {
				log.Printf("Coordinator: Failed to send Prepare RPC to server %d for transaction %d\n", i, tid)
				co.abortTransaction(tid, relevant)
				co.mu.Lock()
				tran.Phase = PhaseAborted
				co.mu.Unlock()
				co.respChan <- ResponseMsg{tid: tid, committed: false, readValues: nil}
				return

			}

			log.Printf("Coordinator: Received Prepare RPC reply from server %d for transaction %d\n", i, tid)

			if reply.Relevant {
				relevant[i] = true
				votes[i] = reply.Vote
				if !reply.Vote {
					allVotedYes = false
				}
			}

			log.Printf("Coordinator Reply: Server %d voted %v for transaction %d\n", i, reply.Vote, tid)

		}

		co.mu.Lock()
		tran.Relevant = relevant
		co.mu.Unlock()

		log.Printf("Coordinator: Checking votes for transaction %d\n", tid)

		if !allVotedYes {
			log.Printf("Coordinator: At least one server voted No for transaction %d, aborting transaction\n", tid)
			co.abortTransaction(tid, relevant)
			co.mu.Lock()
			tran.Phase = PhaseAborted
			co.mu.Unlock()
			co.respChan <- ResponseMsg{tid: tid, committed: false, readValues: nil}
			return

		}

		// ======================

		// PHASE 2: PRECOMMIT

		// ======================

		log.Printf("Coordinator: Sending PreCommit RPC to all servers for transaction %d\n", tid)

		for i := range relevant {
			if co.killed() {
				return
			}

			args := &RPCArgs{Tid: tid}
			retry := 0
			for !co.sendPreCommit(i, args) {
				log.Printf("Coordinator: Failed to send PreCommit RPC to server %d for transaction %d\n", i, tid)

				if co.killed() {
					return
				}

				if retry > 3 {
					log.Printf("Coordinator: Timeout waiting for PreCommit to server %d for transaction %d, aborting\n", i, tid)
					co.Kill()
					log.Printf("killing coordinator")
					co.abortTransaction(tid, relevant)
					co.mu.Lock()
					tran.Phase = PhaseAborted
					co.mu.Unlock()
					co.respChan <- ResponseMsg{tid: tid, committed: false, readValues: nil}
					return

				}

				retry++

			}

		}

		co.mu.Lock()
		tran.Phase = PhasePreCommit
		co.mu.Unlock()

		// ======================

		// PHASE 3: COMMIT

		// ======================

		log.Printf("Coordinator: Sending Commit RPC to all servers for transaction %d\n", tid)
		readValues := make(map[string]interface{})

		for i := range relevant {

			if co.killed() {
				return
			}

			args := &RPCArgs{Tid: tid}
			reply := &CommitReply{}
			log.Printf("Coordinator: Sending Commit RPC to server %d for transaction %d\n", i, tid)
			co.sendCommit(i, args, reply)

			for !co.sendCommit(i, args, reply) {
				log.Printf("Coordinator: Failed to send Commit RPC to server %d for transaction %d\n", i, tid)

				if co.killed() {
					return
				}

			}

			log.Printf("Coordinator: Received Commit RPC reply from server %d for transaction %d\n", i, tid)

			for k, v := range reply.ReadValues {
				readValues[k] = v
			}

		}

		co.mu.Lock()
		tran.Phase = PhaseCommitted
		tran.ReadValues = readValues
		co.mu.Unlock()
		co.respChan <- ResponseMsg{tid: tid, committed: true, readValues: readValues}

	}()

}

// Abort the transaction

func (co *Coordinator) abortTransaction(tid int, relevant map[int]bool) {

	log.Printf("Coordinator: Aborting transaction %d\n", tid)

	// Send Abort RPC to all servers

	for i := range relevant {

		log.Printf("Coordinator: Sending Abort RPC to server %d for transaction %d\n", i, tid)
		if co.killed() {
			log.Printf("Coordinator: Aborting transaction %d due to kill signal\n", tid)
			return
		}

		args := &RPCArgs{Tid: tid}

		for !co.sendAbort(i, args) {
			log.Printf("Coordinator: Failed to send Abort RPC to server %d for transaction %d\n", i, tid)
			if co.killed() {
				return
			}

		}

	}

	log.Printf("Coordinator: Transaction %d aborted\n", tid)

}

func (co *Coordinator) run3PC(tid int, tran *Transaction) bool {
	log.Printf("Coordinator: Running 3PC for transaction %d\n", tid)
	if tran.Phase == PhasePrepare {
		log.Printf("Coordinator, Run3RPC: Transaction %d in PhasePrepare\n", tid)

		relevant := make(map[int]bool)
		votes := make(map[int]bool)
		allVotedYes := true

		// Send Prepare RPC to all servers

		log.Printf("Coordinator: Sending Prepare RPC to all servers for transaction %d\n", tid)

		for i := 0; i < co.serversN; i++ {
			log.Printf("Coordinator: Sending Prepare RPC to server %d for transaction %d\n", i, tid)
			if co.killed() {
				return false
			}

			args := &RPCArgs{Tid: tid}
			reply := &PrepareReply{}

			for !co.sendPrepare(i, args, reply) {
				log.Printf("Coordinator: Failed to send Prepare RPC to server %d for transaction %d\n", i, tid)
				co.abortTransaction(tid, relevant)
				co.mu.Lock()
				tran.Phase = PhaseAborted
				co.mu.Unlock()
				co.respChan <- ResponseMsg{tid: tid, committed: false, readValues: nil}
				return false

			}

			log.Printf("Coordinator: Received Prepare RPC reply from server %d for transaction %d\n", i, tid)

			if reply.Relevant {
				relevant[i] = true
				votes[i] = reply.Vote
				if !reply.Vote {
					allVotedYes = false
				}
			}

			log.Printf("Coordinator Reply: Server %d voted %v for transaction %d\n", i, reply.Vote, tid)

		}

		// co.mu.Lock()
		tran.Relevant = relevant
		// co.mu.Unlock()

		log.Printf("Coordinator: Checking votes for transaction %d in 3PC\n", tid)

		if !allVotedYes {
			log.Printf("Coordinator: At least one server voted No for transaction %d, aborting transaction\n", tid)
			co.abortTransaction(tid, relevant)
			co.mu.Lock()
			tran.Phase = PhaseAborted
			co.mu.Unlock()
			co.respChan <- ResponseMsg{tid: tid, committed: false, readValues: nil}
			return false

		}

		log.Printf("Coordinator: All servers voted Yes for transaction %d, proceeding to PreCommit\n", tid)
		tran.Phase = PhasePreCommit

	}

	if tran.Phase == PhasePreCommit {
		log.Printf("Coordinator, Run3RPC: Sending PreCommit RPC to all servers for transaction %d\n", tid)

		for i := range tran.Relevant {
			if co.killed() {
				return false
			}

			args := &RPCArgs{Tid: tid}
			retry := 0
			for !co.sendPreCommit(i, args) {
				log.Printf("Coordinator: Failed to send PreCommit RPC to server %d for transaction %d\n", i, tid)

				if co.killed() {
					return false
				}

				if retry > 3 {
					log.Printf("Coordinator: Timeout waiting for PreCommit to server %d for transaction %d, aborting\n", i, tid)
					co.Kill()
					log.Printf("killing coordinator")
					co.abortTransaction(tid, tran.Relevant)

					tran.Phase = PhaseAborted

					co.respChan <- ResponseMsg{tid: tid, committed: false, readValues: nil}
					return false

				}

				retry++

			}

		}

		tran.Phase = PhaseCommitted

		log.Printf("Coordinator, Run3RPC: Transaction %d in PhasePreCommit finished, proceed to Commit Phase\n", tid)

	}

	if tran.Phase == PhaseCommitted {

		log.Printf("Coordinator: Sending Commit RPC to all servers for transaction %d\n", tid)
		readValues := make(map[string]interface{})

		for i := range tran.Relevant {

			if co.killed() {
				return false
			}

			args := &RPCArgs{Tid: tid}
			reply := &CommitReply{}
			log.Printf("Coordinator: Sending Commit RPC to server %d for transaction %d\n", i, tid)
			co.sendCommit(i, args, reply)

			for !co.sendCommit(i, args, reply) {
				log.Printf("Coordinator: Failed to send Commit RPC to server %d for transaction %d\n", i, tid)

				if co.killed() {
					return false
				}

			}

			log.Printf("Coordinator: Received Commit RPC reply from server %d for transaction %d\n", i, tid)

			for k, v := range reply.ReadValues {
				readValues[k] = v
			}

		}

		tran.Phase = PhaseCommitted
		tran.ReadValues = readValues

		co.respChan <- ResponseMsg{tid: tid, committed: true, readValues: readValues}

	}

	log.Printf("Coordinator: Transaction %d in PhaseCommitted, read values: %v\n", tid, tran.ReadValues)
	return true

}

// Initialize new Coordinator

//

// This will be called at the beginning of a test to create a new Coordinator

// It will also be called when the Coordinator restarts, so you'll need to trigger recovery here

// respChan is how you'll send messages to the client to notify it of committed or aborted transactions

func MakeCoordinator(servers []*labrpc.ClientEnd, respChan chan ResponseMsg) *Coordinator {

	co := &Coordinator{
		servers:  servers,
		respChan: respChan,

		// Initialize other fields here
		tran:     make(map[int]*Transaction),
		serversN: len(servers),
	}

	go co.recover()
	return co

}

// recover is called when the Coordinator restarts

func (co *Coordinator) recover() {

	co.mu.Lock()
	defer co.mu.Unlock()

	tranStates := make(map[int]map[int]ServerTransaction)

	for i := 0; i < co.serversN; i++ {

		if co.killed() {
			return

		}

		reply := &QueryReply{}

		for !co.sendQuery(i, reply) {
			if co.killed() {
				return

			}

		}

		for tid, state := range reply.Transactions {
			if _, exists := tranStates[tid]; !exists {
				tranStates[tid] = make(map[int]ServerTransaction)
			}

			tranStates[tid][i] = state

		}

	}

	for tid, serverStates := range tranStates {

		// co.mu.Lock()

		if _, exists := co.tran[tid]; !exists {

			co.tran[tid] = &Transaction{
				Phase:      PhasePrepare,
				Relevant:   make(map[int]bool),
				ReadValues: make(map[string]interface{}),
			}

		}

		tran := co.tran[tid]

		// co.mu.Unlock()

		anyAborted := false
		anyCommitted := false
		allCommitted := true
		anyPreCommitted := false
		anyVotedYes := false
		relevant := make(map[int]bool)

		for server, state := range serverStates {

			if len(state.Operations) > 0 {
				relevant[server] = true

			}

			if state.State == stateAborted || state.State == stateVotedNo {
				anyAborted = true

			}

			if state.State == stateCommitted {
				anyCommitted = true

			} else {
				allCommitted = false

			}

			if state.State == statePreCommitted {
				anyPreCommitted = true

			}

			if state.State == stateVotedYes {
				anyVotedYes = true

			}

		}

		// co.mu.Lock()

		log.Printf("Coordinator: Information for transactions %d, relevant: %v, anyAborted: %v, anyCommitted: %v, allCommitted: %v, anyPreCommitted: %v, anyVotedYes: %v\n", tid, relevant, anyAborted, anyCommitted, allCommitted, anyPreCommitted, anyVotedYes)
		tran.Relevant = relevant

		// co.mu.Unlock()

		if anyAborted {
			log.Printf("Coordinator: Transaction %d entering anyAbort Stage\n", tid)
			// co.mu.Lock()
			tran.Phase = PhaseAborted
			// co.mu.Unlock()
			co.abortTransaction(tid, relevant)
			co.respChan <- ResponseMsg{tid: tid, committed: false, readValues: nil}

		} else if anyCommitted && !allCommitted {
			log.Printf("Coordinator: Transaction %d entering anyCommit Stage\n", tid)
			// co.mu.Lock()
			tran.Phase = PhaseCommitted
			// co.mu.Unlock()
			co.run3PC(tid, tran)

		} else if anyPreCommitted {
			log.Printf("Coordinator: Transaction %d entering anyPreCommit Stage\n", tid)

			// co.mu.Lock()
			tran.Phase = PhasePreCommit
			// co.mu.Unlock()

			co.run3PC(tid, tran)

		} else if anyVotedYes {
			log.Printf("Coordinator: Transaction %d entering anyVotedYes Stage\n", tid)
			// co.mu.Lock()
			tran.Phase = PhasePrepare
			// co.mu.Unlock()
			co.run3PC(tid, tran)

		}

	}

}

// Like in Raft, each send method returns true if the request succeeded and false if it timed out

// They are guaranteed to return *unless* the handler function on the server side does not return

func (co *Coordinator) sendPrepare(server int, args *RPCArgs, reply *PrepareReply) bool {
	return co.servers[server].Call("Server.Prepare", args, reply)

}

func (co *Coordinator) sendAbort(server int, args *RPCArgs) bool {
	reply := struct{}{}
	return co.servers[server].Call("Server.Abort", args, &reply)

}

func (co *Coordinator) sendQuery(server int, reply *QueryReply) bool {
	return co.servers[server].Call("Server.Query", struct{}{}, reply)

}

func (co *Coordinator) sendPreCommit(server int, args *RPCArgs) bool {
	reply := struct{}{}
	return co.servers[server].Call("Server.PreCommit", args, &reply)

}

func (co *Coordinator) sendCommit(server int, args *RPCArgs, reply *CommitReply) bool {
	return co.servers[server].Call("Server.Commit", args, reply)

}

// The tester doesn't halt goroutines created by the Coordinator after each test,

// but it does call the Kill() method. Your code can use killed() to

// check whether Kill() has been called. The use of atomic avoids the

// need for a lock.

//

// The issue is that long-running goroutines use memory and may chew

// up CPU time, perhaps causing later tests to fail and generating

// confusing debug output. Any goroutine with a long-running loop

// should call killed() to check whether it should stop.

func (co *Coordinator) Kill() {
	atomic.StoreInt32(&co.dead, 1)

}

func (co *Coordinator) killed() bool {
	z := atomic.LoadInt32(&co.dead)
	return z == 1

}
